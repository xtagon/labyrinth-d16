; Labyrinth for DCPU-16
; =====================

; - Copyright 2012 Justin Workman <xtagon@gmail.com>
; - Inspired by Daniel Boswell's labyrnth.bas for QBasic
; - Implemented for DCPU-16 v1.7 specifications

SET PC, main

:display_hwi DAT 0 ; LEM1802 interupt address
:display_buffer DAT 0x8000 ; Starting location for video RAM
:keyboard_hwi DAT 0 ; Generic Keyboard interupt address

; 0x00 - Empty
; 0x01 - Wall
; 0x02 - Water
; 0x03 - Planks
; 0x04 - Planks on Water
; 0x10 - Red Key
; 0x11 - Green Key
; 0x12 - Blue Key
; 0x13 - Yellow Key
; 0x14 - Brown Key
; 0x15 - Grey Key
; 0x20 - Red Door
; 0x21 - Green Door
; 0x22 - Blue Door
; 0x23 - Yellow Door
; 0x24 - Brown Door
; 0x25 - Grey Door
; 0xFF - Finish
:map_size DAT 12, 12 ; WIDTH, HEIGHT
:map_data
	DAT 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101
	DAT 0x0100, 0x0100, 0x0200, 0x0103, 0x0002, 0x0201
	DAT 0x0100, 0x0100, 0x0100, 0x0100, 0x0101, 0x0001
	DAT 0x0100, 0x0010, 0x0100, 0x0000, 0x0111, 0x0001
	DAT 0x0101, 0x0100, 0x0122, 0x0100, 0x0101, 0x0101
	DAT 0x0103, 0x0000, 0x0100, 0x0100, 0x0000, 0x0101
	DAT 0x0101, 0x0101, 0x0103, 0x2100, 0x0101, 0x0101
	DAT 0x0101, 0x0002, 0x0000, 0x0100, 0x0000, 0x1201
	DAT 0x0101, 0x0001, 0x0000, 0x0003, 0x0101, 0x0101
	DAT 0x0101, 0x0001, 0x0101, 0x0101, 0x0101, 0x0101
	DAT 0x0103, 0x0020, 0x0002, 0x0000, 0x0000, 0xFF01
	DAT 0x0101, 0x0101, 0x0101, 0x0101, 0x0101, 0x0101

:font
	DAT 0x0000, 0x0000, 0x0000, 0x0000 ; Empty
	DAT 0x7F7F, 0x7F7F, 0x7F7F, 0x7F00 ; Wall
	DAT 0x552A, 0x552A, 0x552A, 0x5500 ; Water
	DAT 0x4C6C, 0x6636, 0x331B, 0x1900 ; Planks

:main
	JSR detect_devices
	JSR init_devices
	JSR render_map
	SUB PC, 1

:detect_devices
	SET I, 0
	HWN J
:next_device
	HWQ I
	; Check for the LEM1802 display (0x7349F615)
	IFE A, 0xF615
	IFE B, 0x7349
		SET [display_hwi], I
	; Check for Generic Keyboard (0x30CF7406)
	IFE A, 0x7406
	IFE B, 0x30CF
		SET [keyboard_hwi], I
	; Keep 'em comin'
	ADD I, 1
	IFN I, J
		SET PC, next_device
	SET PC, POP

:init_devices
	JSR init_display
	JSR init_keyboard
	SET PC, POP

:init_display
	JSR init_display_screen
	JSR init_display_font
	SET PC, POP

:init_display_screen
	SET A, 0
	SET B, [display_buffer]
	HWI [display_hwi]
	SET PC, POP

:init_display_font
	SET A, 1
	SET B, font
	HWI [display_hwi]
	SET PC, POP

:init_keyboard
	SET A, 0
	HWI [keyboard_hwi]
	SET PC, POP

:render_map
	SET I, 0
:render_map_next
	JSR render_map_row
	ADD I, 1
	IFG [map_size + 1], I
		SET PC, render_map_next
	SET PC, POP

:render_map_row
	SET J, 0
:render_map_row_next
	JSR render_map_block
	ADD J, 1
	IFG [map_size], J
		SET PC, render_map_row_next
	SET PC, POP

:render_map_block
	; Set A to the block type that we wish to draw
	SET A, [map_size]
	DIV A, 2
	MUL A, I
	SET B, J
	DIV B, 2
	ADD A, B
	ADD A, map_data
	SET A, [A]
	; Parse it into the octet that we want
	SET B, J
	MOD B, 2
	JSR unpack_octet_pair
	; Set A to the font location for this block
	MUL A, 2
	; Set B to the video RAM address we wish to set
	SET B, 32
	MUL B, I
	SET C, J
	MUL C, 2
	ADD B, C
	ADD B, [display_buffer]
	; Draw the left side of the block
	BOR A, 0x7000
	SET [B], A
	; Draw the right side of the block
	ADD A, 1
	SET [B + 1], A
	; We're done here
	SET PC, POP

:unpack_octet_pair
	IFE B, 1
		SET PC, unpack_octet_pair_right
	SET PC, unpack_octet_pair_left
:unpack_octet_pair_right
	AND A, 0x00FF
	SET PC, POP
:unpack_octet_pair_left
	AND A, 0xFF00
	SHR A, 8
	SET PC, POP
