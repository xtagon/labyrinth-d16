; Labyrinth for DCPU-16
; =====================
;
; - Copyright 2012 Justin Workman <xtagon@gmail.com>
; - Inspired by Daniel Boswell's labyrnth.bas for QBasic
; - Implemented for DCPU-16 v1.7 specifications


JSR init
JSR main
SUB PC, 1


; Player Variables
; ----------------

:player_position DAT 0, 0 ; X, Y
:player_movement DAT 0, 0 ; X, Y


; Hardware Variables
; ----------------

:display_hwi DAT 0 ; LEM1802 interupt address
:display_buffer DAT 0x8000 ; Starting location for video RAM
:keyboard_hwi DAT 0 ; Generic Keyboard interupt address


; Map Data
; --------
;
; 0x00 - Empty
; 0x11 - Stone
; 0x42 - Water
; 0x63 - Planks
; 0x64 - Bridge
; 0x25 - Red Key
; 0x35 - Green Key
; 0x45 - Blue Key
; 0x55 - Yellow Key
; 0x65 - Brown Key
; 0x75 - Purple Key
; 0x26 - Red Door
; 0x36 - Green Door
; 0x46 - Blue Door
; 0x56 - Yellow Door
; 0x66 - Brown Door
; 0x76 - Purple Door
; 0xFF - Finish

:map_size DAT 12, 12 ; WIDTH, HEIGHT
:map_start DAT 1, 1 ; X, Y
:map_data
	DAT 0x1111, 0x1111, 0x1111, 0x1111, 0x1111, 0x1111
	DAT 0x1100, 0x1100, 0x4200, 0x1163, 0x0042, 0x4211
	DAT 0x1100, 0x1100, 0x1100, 0x1100, 0x1111, 0x0011
	DAT 0x1100, 0x0175, 0x1100, 0x0000, 0x1135, 0x0011
	DAT 0x1111, 0x1100, 0x1146, 0x1100, 0x1111, 0x1111
	DAT 0x1163, 0x0000, 0x1100, 0x1100, 0x0000, 0x1111
	DAT 0x1111, 0x1111, 0x1163, 0x3600, 0x1111, 0x1111
	DAT 0x1111, 0x0042, 0x0000, 0x1100, 0x0000, 0x4511
	DAT 0x1111, 0x0011, 0x0000, 0x0063, 0x1111, 0x1111
	DAT 0x1111, 0x0011, 0x1111, 0x1111, 0x1111, 0x1111
	DAT 0x1163, 0x0076, 0x0042, 0x0000, 0x0000, 0xFF11
	DAT 0x1111, 0x1111, 0x1111, 0x1111, 0x1111, 0x1111


; Font (Sprite Table) and Color Palette
; -------------------------------------

:display_font
	DAT 0x0000, 0x0000, 0x0000, 0x0000 ; Empty
	DAT 0x3E7F, 0x7F7F, 0x7F7F, 0x3E00 ; Stone
	DAT 0x9259, 0x4536, 0x9259, 0x4436 ; Water
	DAT 0x4C6C, 0x6636, 0x331B, 0x1900 ; Planks
	DAT 0x7777, 0x7777, 0x7777, 0x7700 ; Bridge
	DAT 0x0046, 0x4979, 0x0600, 0x0000 ; Key
	DAT 0x7C7E, 0x7F7F, 0x7F6E, 0x7C00 ; Door
	DAT 0x0808, 0x1C7F, 0x1C08, 0x0800 ; Player

:display_palette
	DAT 0x0111, 0x0333, 0x0A44, 0x05A5 ; Black, Grey,   Red,   Green
	DAT 0x058D, 0x0CD5, 0x0952, 0x085B ; Blue,  Yellow, Brown, Purple
	DAT 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF
	DAT 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF


; Main Routines
; -------------

:init
	JSR detect_devices
	JSR init_devices
	JSR init_player
	SET PC, POP

:main
	JSR reset_player_movement
	JSR render_map
	JSR process_input
	JSR process_player_movement
	SET PC, main


; Hardware Routines
; -----------------

:detect_devices
	SET I, 0
	HWN J
:next_device
	HWQ I
	; Check for the LEM1802 display (0x7349F615)
	IFE A, 0xF615
	IFE B, 0x7349
		SET [display_hwi], I
	; Check for Generic Keyboard (0x30CF7406)
	IFE A, 0x7406
	IFE B, 0x30CF
		SET [keyboard_hwi], I
	; Keep 'em comin'
	ADD I, 1
	IFN I, J
		SET PC, next_device
	SET PC, POP

:init_devices
	JSR init_display
	JSR init_keyboard
	SET PC, POP

:init_display
	JSR init_display_screen
	JSR init_display_font
	JSR init_display_palette
	SET PC, POP

:init_display_screen
	SET A, 0
	SET B, [display_buffer]
	HWI [display_hwi]
	SET PC, POP

:init_display_font
	SET A, 1
	SET B, display_font
	HWI [display_hwi]
	SET PC, POP

:init_display_palette
	SET A, 2
	SET B, display_palette
	HWI [display_hwi]
	SET PC, POP

:init_keyboard
	SET A, 0
	HWI [keyboard_hwi]
	SET PC, POP


; Map Routines
; ------------

:map_get_block
	; Set A to the block type info
	SET A, [map_size]
	DIV A, 2
	MUL A, Y
	SET B, X
	DIV B, 2
	ADD A, B
	ADD A, map_data
	SET A, [A]
	; Parse it into the octet that we want
	SET B, X
	JSR get_octet
	; We're done here
	SET PC, POP

; Player Routines
; ---------------

:init_player
	SET [player_position], [map_start]
	SET [player_position + 1], [map_start + 1]
	SET PC, POP

:reset_player_movement
	SET [player_movement], [player_position]
	SET [player_movement + 1], [player_position + 1]
	SET PC, POP

:process_player_movement
	; Set A to the block we're moving into
	SET X, [player_movement]
	SET Y, [player_movement + 1]
	JSR map_get_block
	; If there is a stone in the way, don't move here
	IFE A, 0x11
		SET PC, POP
	; Move the player
	JSR player_move
	; We're done here
	SET PC, POP

:player_move
	SET [player_position], [player_movement]
	SET [player_position + 1], [player_movement + 1]
	SET PC, POP


; Rendering
; ---------

:render_map
	SET I, 0
:render_map_next
	JSR render_map_row
	ADD I, 1
	IFG [map_size + 1], I
		SET PC, render_map_next
	SET PC, POP

:render_map_row
	SET J, 0
:render_map_row_next
	JSR render_map_block
	ADD J, 1
	IFG [map_size], J
		SET PC, render_map_row_next
	SET PC, POP

:render_map_block
	SET A, 0
	IFE J, [player_position]
	IFE I, [player_position + 1]
		SET PC, render_map_block_player
	SET PC, render_map_block_other
:render_map_block_player
	; Set C to the player's color mask
	SET C, 0xF000
	; Set A to the font location for the player
	SET A, 0x000E
	; Draw the player
	SET PC, render_map_block_draw
:render_map_block_other
	; Get this block's info
	SET X, J
	SET Y, I
	JSR map_get_block
	; Set C to the block color mask
	SET C, A
	SHR C, 4
	SHL C, 12
	; Set A to the font location for this block
	AND A, 0x000F
	MUL A, 2
:render_map_block_draw
	; Set B to the video RAM address we wish to set
	SET PUSH, C
	SET B, 32
	MUL B, I
	SET C, J
	MUL C, 2
	ADD B, C
	ADD B, [display_buffer]
	SET C, POP
	; Draw the left side of the block
	BOR A, C
	SET [B], A
	; Draw the right side of the block
	ADD A, 1
	SET [B + 1], A
	; We're done here
	SET PC, POP


; Utility Routines
; ----------------

:get_octet
	MOD B, 2
	IFE B, 1
		SET PC, get_octet_right
:get_octet_left
	AND A, 0xFF00
	SHR A, 8
	SET PC, POP
:get_octet_right
	AND A, 0x00FF
	SET PC, POP


; Input Handling
; --------------

:process_input
	; Set C to the next key typed
	SET A, 1
	HWI [keyboard_hwi]
	; Update player movement
	IFE C, 0x80 ; Arrow up
		SUB [player_movement + 1], 1
	IFE C, 0x81 ; Arrow down
		ADD [player_movement + 1], 1
	IFE C, 0x82 ; Arrow left
		SUB [player_movement], 1
	IFE C, 0x83 ; Arrow left
		ADD [player_movement], 1
	; We're done here
	SET PC, POP
