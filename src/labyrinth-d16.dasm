; Labyrinth for DCPU-16
; =====================

; - Copyright 2012 Justin Workman <xtagon@gmail.com>
; - Inspired by Daniel Boswell's labyrnth.bas for QBasic
; - Implemented for DCPU-16 v1.7 specifications

SET PC, main

:display_hwi DAT 0 ; LEM1802 interupt address
:display_buffer DAT 0x8000 ; Starting location for video RAM

; 0x0000 - Empty
; 0x0001 - Wall
:map_size DAT 8, 8 ; WIDTH, HEIGHT
:map_data
	DAT 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001 ; WWWWWWWW
	DAT 0x0001, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0001 ; W..W...W
	DAT 0x0001, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001 ; WW.W.W.W
	DAT 0x0001, 0x0000, 0x0000, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001 ; W..W.W.W
	DAT 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001 ; W.....WW
	DAT 0x0001, 0x0001, 0x0001, 0x0000, 0x0001, 0x0000, 0x0001, 0x0001 ; WWW.W.WW
	DAT 0x0001, 0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000, 0x0001 ; W...W..W
	DAT 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001 ; WWWWWWWW

:font
	DAT 0x0000, 0x0000 ; Empty
	DAT 0xFFFF, 0xFFFF ; Wall

:main
	JSR detect_devices
	JSR init_display
	JSR render_map
	SUB PC, 1

:detect_devices
	SET I, 0
	HWN J
:next_device
	HWQ I
	; Check for the LEM1802 display (0x7349F615)
	IFE A, 0xF615
	IFE B, 0x7349
		SET [display_hwi], I
	; Keep 'em comin'
	ADD I, 1
	IFN I, J
		SET PC, next_device
	SET PC, POP

:init_display
	JSR init_display_screen
	JSR init_display_font
	SET PC, POP

:init_display_screen
	SET A, 0
	SET B, [display_buffer]
	HWI [display_hwi]
	SET PC, POP

:init_display_font
	SET A, 1
	SET B, font
	HWI [display_hwi]
	SET PC, POP

:render_map
	SET I, 0
:render_map_next
	JSR render_map_row
	ADD I, 1
	IFG [map_size], I
		SET PC, render_map_next
	SET PC, POP

:render_map_row
	SET J, 0
:render_map_row_next
	JSR render_map_block
	ADD J, 1
	IFG [map_size + 1], J
		SET PC, render_map_row_next
	SET PC, POP

:render_map_block
	; Set A to the block type that we wish to draw
	SET A, [map_size]
	MUL A, I
	ADD A, J
	ADD A, map_data
	SET A, [A]
	; Set B to the video RAM address we wish to set
	; Remember, we're drawing two cells per block
	SET B, 32
	MUL B, I
	SET C, J
	MUL C, 2
	ADD B, C
	ADD B, [display_buffer]
	; Draw the left side of the block
	BOR A, 0x7000
	SET [B], A
	; Draw the right side of the block
	SET [B + 1], A
	; We're done here
	SET PC, POP
