; Labyrinth for DCPU-16
; =====================

; - Copyright 2012 Justin Workman <xtagon@gmail.com>
; - Inspired by Daniel Boswell's labyrnth.bas for QBasic
; - Implemented for DCPU-16 v1.7 specifications

JSR init
JSR main
SUB PC, 1

:display_hwi DAT 0 ; LEM1802 interupt address
:display_buffer DAT 0x8000 ; Starting location for video RAM
:keyboard_hwi DAT 0 ; Generic Keyboard interupt address

:player_position DAT 0, 0 ; X, Y

; 0x00 - Empty
; 0x11 - Stone
; 0x42 - Water
; 0x63 - Planks
; 0x64 - Bridge
; 0x25 - Red Key
; 0x35 - Green Key
; 0x45 - Blue Key
; 0x55 - Yellow Key
; 0x65 - Brown Key
; 0x75 - Purple Key
; 0x26 - Red Door
; 0x36 - Green Door
; 0x46 - Blue Door
; 0x56 - Yellow Door
; 0x66 - Brown Door
; 0x76 - Purple Door
; 0xFF - Finish
:map_size DAT 12, 12 ; WIDTH, HEIGHT
:map_start DAT 1, 1 ; X, Y
:map_data
	DAT 0x1111, 0x1111, 0x1111, 0x1111, 0x1111, 0x1111
	DAT 0x1100, 0x1100, 0x4200, 0x1163, 0x0042, 0x4211
	DAT 0x1100, 0x1100, 0x1100, 0x1100, 0x1111, 0x0011
	DAT 0x1100, 0x0175, 0x1100, 0x0000, 0x1135, 0x0011
	DAT 0x1111, 0x1100, 0x1146, 0x1100, 0x1111, 0x1111
	DAT 0x1163, 0x0000, 0x1100, 0x1100, 0x0000, 0x1111
	DAT 0x1111, 0x1111, 0x1163, 0x3600, 0x1111, 0x1111
	DAT 0x1111, 0x0042, 0x0000, 0x1100, 0x0000, 0x4511
	DAT 0x1111, 0x0011, 0x0000, 0x0063, 0x1111, 0x1111
	DAT 0x1111, 0x0011, 0x1111, 0x1111, 0x1111, 0x1111
	DAT 0x1163, 0x0076, 0x0042, 0x0000, 0x0000, 0xFF11
	DAT 0x1111, 0x1111, 0x1111, 0x1111, 0x1111, 0x1111

:display_font
	DAT 0x0000, 0x0000, 0x0000, 0x0000 ; Empty
	DAT 0x3E7F, 0x7F7F, 0x7F7F, 0x3E00 ; Stone
	DAT 0x9259, 0x4536, 0x9259, 0x4436 ; Water
	DAT 0x4C6C, 0x6636, 0x331B, 0x1900 ; Planks
	DAT 0x7777, 0x7777, 0x7777, 0x7700 ; Bridge
	DAT 0x0046, 0x4979, 0x0600, 0x0000 ; Key
	DAT 0x7C7E, 0x7F7F, 0x7F6E, 0x7C00 ; Door
	DAT 0x0808, 0x1C7F, 0x1C08, 0x0800 ; Player

:display_palette
	DAT 0x0111, 0x0333, 0x0A44, 0x05A5 ; Black, Grey,   Red,   Green
	DAT 0x058D, 0x0CD5, 0x0952, 0x085B ; Blue,  Yellow, Brown, Purple
	DAT 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF
	DAT 0x0FFF, 0x0FFF, 0x0FFF, 0x0FFF

:init
	JSR detect_devices
	JSR init_devices
	JSR init_player
	SET PC, POP

:main
	JSR render_map
	JSR process_input
	SET PC, main

:detect_devices
	SET I, 0
	HWN J
:next_device
	HWQ I
	; Check for the LEM1802 display (0x7349F615)
	IFE A, 0xF615
	IFE B, 0x7349
		SET [display_hwi], I
	; Check for Generic Keyboard (0x30CF7406)
	IFE A, 0x7406
	IFE B, 0x30CF
		SET [keyboard_hwi], I
	; Keep 'em comin'
	ADD I, 1
	IFN I, J
		SET PC, next_device
	SET PC, POP

:init_devices
	JSR init_display
	JSR init_keyboard
	SET PC, POP

:init_display
	JSR init_display_screen
	JSR init_display_font
	JSR init_display_palette
	SET PC, POP

:init_display_screen
	SET A, 0
	SET B, [display_buffer]
	HWI [display_hwi]
	SET PC, POP

:init_display_font
	SET A, 1
	SET B, display_font
	HWI [display_hwi]
	SET PC, POP

:init_display_palette
	SET A, 2
	SET B, display_palette
	HWI [display_hwi]
	SET PC, POP

:init_keyboard
	SET A, 0
	HWI [keyboard_hwi]
	SET PC, POP

:init_player
	SET [player_position], [map_start]
	SET [player_position + 1], [map_start + 1]
	SET PC, POP

:render_map
	SET I, 0
:render_map_next
	JSR render_map_row
	ADD I, 1
	IFG [map_size + 1], I
		SET PC, render_map_next
	SET PC, POP

:render_map_row
	SET J, 0
:render_map_row_next
	JSR render_map_block
	ADD J, 1
	IFG [map_size], J
		SET PC, render_map_row_next
	SET PC, POP

:render_map_block
	SET A, 0
	IFE J, [player_position]
	IFE I, [player_position + 1]
		SET PC, render_map_block_player
	SET PC, render_map_block_other
:render_map_block_player
	; Set C to the player's color mask
	SET C, 0xF000
	; Set A to the font location for the player
	SET A, 0x000E
	; Draw the player
	SET PC, render_map_block_draw
:render_map_block_other
	; Set A to the block type info
	SET A, [map_size]
	DIV A, 2
	MUL A, I
	SET B, J
	DIV B, 2
	ADD A, B
	ADD A, map_data
	SET A, [A]
	; Parse it into the octet that we want
	SET B, J
	MOD B, 2
	JSR unpack_octet_pair
	; Set C to the block color mask
	SET C, A
	SHR C, 4
	SHL C, 12
	; Set A to the font location for this block
	AND A, 0x000F
	MUL A, 2
:render_map_block_draw
	; Set B to the video RAM address we wish to set
	SET PUSH, C
	SET B, 32
	MUL B, I
	SET C, J
	MUL C, 2
	ADD B, C
	ADD B, [display_buffer]
	SET C, POP
	; Draw the left side of the block
	BOR A, C
	SET [B], A
	; Draw the right side of the block
	ADD A, 1
	SET [B + 1], A
	; We're done here
	SET PC, POP

:unpack_octet_pair
	IFE B, 1
		SET PC, unpack_octet_pair_right
	SET PC, unpack_octet_pair_left
:unpack_octet_pair_right
	AND A, 0x00FF
	SET PC, POP
:unpack_octet_pair_left
	AND A, 0xFF00
	SHR A, 8
	SET PC, POP

:process_input
	; Set C to the next key typed
	SET A, 1
	HWI [keyboard_hwi]
	; Move the player
	IFE C, 0x80 ; Arrow up
		SUB [player_position + 1], 1
	IFE C, 0x81 ; Arrow down
		ADD [player_position + 1], 1
	IFE C, 0x82 ; Arrow left
		SUB [player_position], 1
	IFE C, 0x83 ; Arrow left
		ADD [player_position], 1
	; We're done here
	SET PC, POP
